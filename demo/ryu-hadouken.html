<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ryu Hadouken — Retro Loop</title>
<style>
  body { background:#0d1117; display:flex; align-items:center; justify-content:center; height:100vh; margin:0; }
  svg { image-rendering: crisp-edges; image-rendering: pixelated; }
  .pixel { shape-rendering: crispEdges; }
  /* Hadouken movement (translateX) */
  @keyframes fly {
    from { transform: translateX(0); }
    to   { transform: translateX(350px); } /* 70 -> 420 = +350 */
  }
  /* small pulsing/scale for the hadouken ball */
  @keyframes pulse {
    0%   { transform: scale(1); opacity:1; }
    50%  { transform: scale(1.08); opacity:0.95; }
    100% { transform: scale(1); opacity:1; }
  }
  .hadouken-group { animation: fly 2s linear infinite; transform-origin: left center; }
  .hadouken-core { animation: pulse 0.5s ease-in-out infinite; }
  /* glow trail */
  .trail circle { opacity:0.14; filter: blur(2px); }
  /* pixel-text style */
  .pixel-text { font-family: "Courier New", monospace; font-weight:700; font-size:24px; shape-rendering:crispEdges; }
  .letter { opacity:0; will-change: opacity; }
  /* subtle screen scanline and vignette (optional) */
  .vignette { fill: url(#vgrad); opacity:0.12; pointer-events:none; }
</style>
</head>
<body>

<!-- SVG canvas -->
<svg id="scene" width="700" height="260" viewBox="0 0 700 260" xmlns="http://www.w3.org/2000/svg" aria-label="Ryu Hadouken retro animation">
  <!-- background -->
  <defs>
    <linearGradient id="vgrad" x1="0" x2="0" y1="0" y2="1">
      <stop offset="0" stop-color="#000" stop-opacity="0.0"/>
      <stop offset="1" stop-color="#000" stop-opacity="0.6"/>
    </linearGradient>
    <!-- a tiny pixel-like filter (keeps edges crisp) -->
    <filter id="softglow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="2" result="b"/>
      <feBlend in="SourceGraphic" in2="b" mode="screen"/>
    </filter>
  </defs>

  <rect width="100%" height="100%" fill="#0d1117" />

  <!-- Ground platform (just for look) -->
  <rect x="0" y="200" width="700" height="60" fill="#081018"/>

  <!-- Ryu (pixel-inspired SVG, arranged as blocks to resemble sprite look) -->
  <g id="ryu" transform="translate(60,40)" class="pixel">
    <!-- hair -->
    <rect x="10" y="20" width="22" height="6" fill="#2b1b10"/>
    <rect x="8" y="26" width="6" height="6" fill="#2b1b10"/>
    <rect x="26" y="26" width="6" height="6" fill="#2b1b10"/>
    <!-- face -->
    <rect x="12" y="30" width="12" height="8" fill="#f0d0a0"/>
    <!-- red headband -->
    <rect x="8" y="28" width="20" height="4" fill="#c30b0b"/>
    <rect x="4" y="26" width="4" height="2" fill="#c30b0b"/>
    <!-- gi (top) -->
    <rect x="8" y="38" width="28" height="22" fill="#f8f8f8"/>
    <!-- sleeves and arms -->
    <rect x="4" y="40" width="6" height="8" fill="#f0d0a0"/>
    <rect x="36" y="40" width="6" height="8" fill="#f0d0a0"/>
    <!-- gloves -->
    <rect x="2" y="46" width="6" height="4" fill="#2a2a2a"/>
    <rect x="40" y="46" width="6" height="4" fill="#2a2a2a"/>
    <!-- belt -->
    <rect x="8" y="58" width="28" height="4" fill="#1a1a1a"/>
    <!-- pants -->
    <rect x="8" y="62" width="12" height="24" fill="#f8f8f8"/>
    <rect x="24" y="62" width="12" height="24" fill="#f8f8f8"/>
    <!-- feet -->
    <rect x="8" y="86" width="10" height="6" fill="#b77b4e"/>
    <rect x="26" y="86" width="10" height="6" fill="#b77b4e"/>
    <!-- subtle shadow -->
    <rect x="6" y="94" width="34" height="3" fill="#051018"/>
  </g>

  <!-- hadouken group: core + trail + glow, positioned near Ryu's hands -->
  <g class="hadouken-group" transform="translate(150,120)" id="hadoukenGroup" filter="url(#softglow)">
    <!-- trail (several faded circles trailing behind) -->
    <g class="trail">
      <circle cx="0" cy="0" r="6" fill="#00bbff" />
      <circle cx="-12" cy="-2" r="7" fill="#52e7ff"/>
      <circle cx="-26" cy="-3" r="8" fill="#9fefff"/>
    </g>
    <!-- animated core with slightly layered shapes for retro look -->
    <g class="core">
      <circle class="hadouken-core" cx="0" cy="0" r="12" fill="#8ff1ff"></circle>
      <circle cx="0" cy="0" r="8" fill="#dfffff" opacity="0.9"></circle>
      <!-- outer ring -->
      <path d="M -18 -6 Q -12 0 -18 6 Q -8 0 -18 -6 Z" fill="#65dfff" opacity="0.25"/>
    </g>
    <!-- a faint blue glow ring -->
    <circle cx="0" cy="0" r="24" fill="#00aaff" opacity="0.08" />
  </g>

  <!-- marker where we consider "the hadouken passes" (invisible in final but useful during tuning)
       keep it invisible by default (opacity 0). If you want to visualize, set opacity to 0.3. -->
  <rect id="passMarker" x="310" y="100" width="2" height="60" fill="#ffffff" opacity="0" />

  <!-- Pixelated name — letters individually as <text> elements for per-letter control -->
  <g id="nameGroup" transform="translate(330,85)" class="pixel-text" fill="#77e6ff" style="text-shadow: 0 0 4px rgba(120,220,255,0.35);">
    <!-- We place letters spaced; opacity controlled via JS -->
    <text id="L"   class="letter" x="0"   y="0">L</text>
    <text id="U"   class="letter" x="24"  y="0">U</text>
    <text id="C"   class="letter" x="48"  y="0">C</text>
    <text id="A"   class="letter" x="72"  y="0">A</text>
    <text id="S1"  class="letter" x="96"  y="0">S</text>
    <text id="sp"  class="letter" x="120" y="0"> </text>
    <text id="S2"  class="letter" x="136" y="0">S</text>
    <text id="U2"  class="letter" x="160" y="0">U</text>
    <text id="K"   class="letter" x="184" y="0">K</text>
    <text id="A2"  class="letter" x="208" y="0">A</text>
    <text id="R2"  class="letter" x="232" y="0">R</text>
  </g>

  <!-- subtle vignette overlay -->
  <rect x="0" y="0" width="700" height="260" class="vignette" />

</svg>

<script>
/*
  Logic:
  - Hadouken animation uses CSS keyframes fly (2s duration) moving from x0 to x0+350.
  - We want the name to start appearing exactly when the hadouken crosses a fixed x (the passMarker at x≈310).
  - Given startX=150 (hadouken group's translateX) and markerX=310, relative delta = (markerX - startX).
  - Fraction along path = delta / totalDistance (350). Multiply by duration (2000ms) gives the time offset.
  - We listen to animationiteration on the hadouken group to schedule the name reveal each loop, and clear previous timers.
*/

(function(){
  const hadouken = document.querySelector('.hadouken-group');
  const durationMs = 2000; // must match CSS animation duration
  const startX = 150;      // initial translate x of the hadouken group (see transform in SVG)
  const markerX = 310;     // x of passMarker rectangle
  const totalDistance = 350; // should match 'to' translate dx in keyframes
  const delta = markerX - startX;
  const passFraction = delta / totalDistance;
  const passTime = Math.max(0, Math.min(1, passFraction)) * durationMs; // ms into animation when it crosses marker

  // letter sequence configuration
  const letters = Array.from(document.querySelectorAll('#nameGroup .letter'));
  const letterDelay = 120; // ms between each letter
  let timeouts = [];

  function resetLetters() {
    // hide all letters immediately
    letters.forEach(l => l.style.opacity = 0);
  }

  function showLettersSequence() {
    resetLetters();
    // schedule each letter to appear one by one
    letters.forEach((el, i) => {
      const t = setTimeout(() => {
        // quick fade-in
        el.style.transition = "opacity 0.12s linear";
        el.style.opacity = 1;
      }, i * letterDelay);
      timeouts.push(t);
    });
  }

  function scheduleForThisLoop() {
    // clear previous
    timeouts.forEach(t => clearTimeout(t));
    timeouts = [];
    // schedule showing letters after passTime (when hadouken crosses)
    const t = setTimeout(showLettersSequence, passTime);
    timeouts.push(t);
    // schedule clearing letters a bit before next iteration to make loop neat
    const clearBefore = 200; // ms before next start
    const t2 = setTimeout(resetLetters, durationMs - clearBefore);
    timeouts.push(t2);
  }

  // initial reset
  resetLetters();
  // schedule first loop after a tiny delay to allow initial paint
  scheduleForThisLoop();

  // when the hadouken animation loops, re-schedule so timing stays precise
  hadouken.addEventListener('animationiteration', () => {
    scheduleForThisLoop();
  });

  // safety: if the user switches tabs and timeouts drift, re-synchronize on focus
  window.addEventListener('focus', () => {
    scheduleForThisLoop();
  });

})();
</script>
</body>
</html>
